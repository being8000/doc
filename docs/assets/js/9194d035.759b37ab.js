"use strict";(self.webpackChunktauri_docs=self.webpackChunktauri_docs||[]).push([[6621],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(t),m=a,v=p["".concat(l,".").concat(m)]||p[m]||c[m]||o;return t?i.createElement(v,r(r({ref:n},u),{},{components:t})):i.createElement(v,r({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var d=2;d<o;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5520:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var i=t(87462),a=t(63366),o=(t(67294),t(3905)),r=["components"],s={},l="Events",d={unversionedId:"guides/features/events",id:"guides/features/events",title:"Events",description:"The Tauri event system is a multi-producer multi-consumer communication primitive that allows message passing between the frontend and the backend.",source:"@site/docs/guides/07-features/events.md",sourceDirName:"guides/07-features",slug:"/guides/features/events",permalink:"/doc/v1/guides/features/events",draft:!1,editUrl:"https://github.com/tauri-apps/tauri-docs/edit/dev/docs/guides/07-features/events.md",tags:[],version:"current",lastUpdatedAt:1652462994,formattedLastUpdatedAt:"5/14/2022",frontMatter:{},sidebar:"guides",previous:{title:"Calling Rust from the frontend",permalink:"/doc/v1/guides/features/command"},next:{title:"Icons",permalink:"/doc/v1/guides/features/icons"}},u={},c=[{value:"Frontend",id:"frontend",level:2},{value:"Global events",id:"global-events",level:3},{value:"Window-specific events",id:"window-specific-events",level:3},{value:"Backend",id:"backend",level:2},{value:"Global events",id:"global-events-1",level:3},{value:"Window-specific events",id:"window-specific-events-1",level:3}],p={toc:c};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"events"},"Events"),(0,o.kt)("p",null,"The Tauri event system is a multi-producer multi-consumer communication primitive that allows message passing between the frontend and the backend.\nIt is analogous to the command system, but payload type check must be written on the event handler and it simplifies communication from the backend to the frontend, working like a channel."),(0,o.kt)("p",null,"A Tauri application can listen and emit to global and window-specific events. Usage from the frontend and the backend are described below."),(0,o.kt)("h2",{id:"frontend"},"Frontend"),(0,o.kt)("p",null,"The event system is accessible on the frontend on the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"window")," modules of the ",(0,o.kt)("inlineCode",{parentName:"p"},"@tauri-apps/api")," package."),(0,o.kt)("h3",{id:"global-events"},"Global events"),(0,o.kt)("p",null,"To use the global event channel, import the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," module and use the ",(0,o.kt)("inlineCode",{parentName:"p"},"emit")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"listen")," functions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { emit, listen } from '@tauri-apps/api/event'\n\n// listen to the `click` event and get a function to remove the event listener\n// there's also a `once` function that subscribes to an event and automatically unsubscribes the listener on the first event\nconst unlisten = await listen('click', event => {\n  // event.event is the event name (useful if you want to use a single callback fn for multiple event types)\n  // event.payload is the payload object\n})\n\n// emits the `click` event with the object payload\nemit('click', {\n  theMessage: 'Tauri is awesome!'\n})\n")),(0,o.kt)("h3",{id:"window-specific-events"},"Window-specific events"),(0,o.kt)("p",null,"Window-specific events are exposed on the ",(0,o.kt)("inlineCode",{parentName:"p"},"window")," module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { appWindow, WebviewWindow } from '@tauri-apps/api/window'\n\n// emit an event that are only visible to the current window\nappWindow.emit('event', { message: 'Tauri is awesome!' })\n\n// create a new webview window and emit an event only to that window\nconst webview = new WebviewWindow('window')\nwebview.emit('event')\n\n")),(0,o.kt)("h2",{id:"backend"},"Backend"),(0,o.kt)("p",null,"On the backend, the global event channel is exposed on the ",(0,o.kt)("inlineCode",{parentName:"p"},"App")," struct, and window-specific events can be emitted using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Window")," trait."),(0,o.kt)("h3",{id:"global-events-1"},"Global events"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use tauri::Manager;\n\n// the payload type must implement `Serialize` and `Clone`.\n#[derive(Clone, serde::Serialize)]\nstruct Payload {\n  message: String,\n}\n\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      // listen to the `event-name` (emitted on any window)\n      let id = app.listen_global("event-name", |event| {\n        println!("got event-name with payload {:?}", event.payload());\n      });\n      // unlisten to the event using the `id` returned on the `listen_global` function\n      // an `once_global` API is also exposed on the `App` struct\n      app.unlisten(id);\n\n      // emit the `event-name` event to all webview windows on the frontend\n      app.emit_all("event-name", Payload { message: "Tauri is awesome!".into() }).unwrap();\n      Ok(())\n    })\n    .run(tauri::generate_context!())\n    .expect("failed to run app");\n}\n')),(0,o.kt)("h3",{id:"window-specific-events-1"},"Window-specific events"),(0,o.kt)("p",null,"To use the window-specific event channel, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Window")," object can be obtained on a command handler or with the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_window")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use tauri::{Manager, Window};\n\n// the payload type must implement `Serialize` and `Clone`.\n#[derive(Clone, serde::Serialize)]\nstruct Payload {\n  message: String,\n}\n\n// init a background process on the command, and emit periodic events only to the window that used the command\n#[tauri::command]\nfn init_process(window: Window) {\n  std::thread::spawn(move || {\n    loop {\n      window.emit("event-name", Payload { message: "Tauri is awesome!".into() }).unwrap();\n    }\n  });\n}\n\nfn main() {\n  tauri::Builder::default()\n    .setup(|app| {\n      // `main` here is the window label; it is defined on the window creation or under `tauri.conf.json`\n      // the default value is `main`. note that it must be unique\n      let main_window = app.get_window("main").unwrap();\n\n      // listen to the `event-name` (emitted on the `main` window)\n      let id = main_window.listen("event-name", |event| {\n        println!("got window event-name with payload {:?}", event.payload());\n      });\n      // unlisten to the event using the `id` returned on the `listen` function\n      // an `once` API is also exposed on the `Window` struct\n      main_window.unlisten(id);\n\n      // emit the `event-name` event to the `main` window\n      main_window.emit("event-name", Payload { message: "Tauri is awesome!".into() }).unwrap();\n      Ok(())\n    })\n    .invoke_handler(tauri::generate_handler![init_process])\n    .run(tauri::generate_context!())\n    .expect("failed to run app");\n}\n')))}m.isMDXComponent=!0}}]);